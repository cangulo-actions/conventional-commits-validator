name: '🚔️ Commits Validation'
description: 'Validate the commits in the PR'
inputs:
  configuration:
    description: 'path to the YML configuration'
    required: true
    default: ''
  add-next-release-type-as-label-to-pr:
    description: >
      flag for adding the release type as a label to the PR.
      Format: 'release-type:<value>'
      Release Types: 'major', 'minor', 'patch', 'no-release'
      Example: 'release-type:major'
    required: true
    default: 'true'
  add-commit-types-as-labels-to-pr:
    description: >
      flag for adding each commit type as a label to the PR.
      Format: '<commit-type>'
      Commit Types: defined in the ./config.default.yml or in the inputs.configuration file
      Example: 'fix,docs'
    required: true
    default: 'true'
  print-summary:
    description: 'flag for printing the release details to the GITHUB_STEP_SUMMARY'
    required: true
    default: 'true'

outputs:
  new-release-triggered:
    value: ${{ steps.validate-commits.outputs.next-release-triggered }}
    description: 'flag to detect if the PR changes will trigger a new release'
  next-version:
    value: ${{ steps.validate-commits.outputs.next-version }}
    description: 'version to be released when the PR is merged'
  next-release-type:
    value: ${{ steps.validate-commits.outputs.next-release-type }}
    description: 'next release type: major, minor or patch'
  changes:
    value: ${{ steps.validate-commits.outputs.changes }}
    description: 'commits parsed into model: [{type, releaseAssociated, scopes, description, originalCommit}]'
  scopes:
    value: ${{ steps.semver.outputs.scopes }}
    description: '{scopename:{version,changes,changelog-record}}'

runs:
  using: "composite"
  steps:
    - name: Validate Context and squashed commit received
      uses: actions/github-script@v7
      with:
        script: |
          if (context.eventName !== 'pull_request') {
              throw new Error(`This GH action only supports pull_request events.`)
          }

    - name: Install dependencies
      shell: bash
      working-directory: ${{ github.action_path }}
      run: |
        npm install --omit=dev

    - name: Process configuration
      uses: actions/github-script@v7
      id: config
      env:
        INPUT_CONFIG: ${{ inputs.configuration }}
        DEFAULT_CONFIG : ${{ github.action_path }}/config.default.yml
        NODE_MODULES_PATH: ${{ github.action_path }}/node_modules
        SCHEMA: ${{ github.action_path }}/config.schema.yml
      with:
        script: |
          const yml = require(`${process.env.NODE_MODULES_PATH}/js-yaml`)
          const Ajv = require(`${process.env.NODE_MODULES_PATH}/ajv`)
          const fs  = require('fs')

          const schemaPath    = process.env.SCHEMA
          const inputConfig   = process.env.INPUT_CONFIG
          const configPath    = inputConfig !== '' ? inputConfig : process.env.DEFAULT_CONFIG;

          const schemaContent = fs.readFileSync(schemaPath)
          const configContent = fs.readFileSync(configPath)
          const schema        = yml.load(schemaContent)
          const config        = yml.load(configContent)

          const ajv       = new Ajv({ useDefaults: true })  // add default values to the config properties
          const validate  = ajv.compile(schema)
          const valid     = validate(config)

          if (!valid) {
            const errorsJson = JSON.stringify(validate.errors, null, 2)
            core.setFailed(`configuration file is not valid: ${errorsJson}`)
          }

          core.startGroup('Configuration')
          console.log('config:', JSON.stringify(config, null, 2))
          core.endGroup()

          core.setOutput('config', config)

    - name: Get commit messages
      uses: actions/github-script@v7
      id: get-commits
      with:
        script: |
          const commitListResponse = await github.rest.pulls.listCommits({
            owner: context.repo.owner,
            repo: context.repo.repo,
            pull_number: context.payload.pull_request.number
          })

          const commits = await Promise.all(commitListResponse.data.map(async commit => {
            const commitDetail = await github.rest.repos.getCommit({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: commit.sha
            });

            const files = commitDetail.data.files.map(file => file.filename);

            return {
              id: commit.sha,
              message: commit.commit.message,
              files: files
            }
          }));

          core.startGroup('Commits')
          console.log('commits', commits)
          core.endGroup()

          core.setOutput('commits', commits)

    - name: >
        Ensure all commits follow conventional commit format `type(scope): description`
      uses: actions/github-script@v7
      env:
        COMMITS: ${{ steps.get-commits.outputs.commits }}
      with:
        script: |
          const { isConventional}     = require('${{ github.action_path }}/functions/parse-change')
          const commits               = JSON.parse(process.env.COMMITS)

          const unconventionalCommits = commits.filter(x => !isConventional(x.message))

          if (unconventionalCommits.length > 0) {
            core.summary
              .addHeading('🛑 Invalid commits:')
              .addCodeBlock(JSON.stringify(unconventionalCommits, null, 2), 'json')
              .write()
            core.setFailed('Errors found validating the commits. Please Check the summary.')
          }

    - name: Parse the changes
      uses: actions/github-script@v7
      id: list-changes
      env:
        CONFIG: ${{ steps.config.outputs.config }} 
        COMMITS: ${{ steps.get-commits.outputs.commits }}
      with:
        script: |
          const { parseChange } = require('${{ github.action_path }}/functions/parse-change')
          const commits         = JSON.parse(process.env.COMMITS)
          const conf            = JSON.parse(process.env.CONFIG)

          const changes = commits
            .map(x => {
              const parsedChange = parseChange(x.message, conf.commits)
              parsedChange.commitId = x.id
              parsedChange.files = x.files
              return parsedChange
            })

          core.startGroup('Changes')
          console.log('changes:', JSON.stringify(changes, null, 2))
          core.endGroup()

          core.setOutput('changes', changes)

    - name: Validate changes
      uses: actions/github-script@v7
      env:
        CONFIG: ${{ steps.config.outputs.config }}
        CHANGES: ${{ steps.list-changes.outputs.changes }}
      with:
        script: |
          const { validateChanges }   = require('${{ github.action_path }}/functions/validate-changes')
          const conf                  = JSON.parse(process.env.CONFIG)
          const changes               = JSON.parse(process.env.CHANGES)

          const supportedCommitTypes  = conf.commits.map(x => x.type)
          const errors                = validateChanges(changes, supportedCommitTypes, conf.scopes)

          if (errors.length > 0) {
            const errorsJSON = JSON.stringify(errors, null, 2)
            core.summary
              .addHeading('🛑 Errors Found validations commits:')
              .addCodeBlock(errorsJSON, 'json')
              .addSeparator()
              .addHeading('Configuration:')
              .addCodeBlock(JSON.stringify(conf, null, 2), 'json')
              .write()
            core.setFailed('Errors found validating the commits. Please Check the summary.')
          }

    - name: Calculate next release
      uses: actions/github-script@v7
      id: validate-commits
      env:
        CONFIG: ${{ steps.config.outputs.config }}
        CHANGES: ${{ steps.list-changes.outputs.changes }}
      with:
        script: |
          const { buildNextReleases }   = require('${{ github.action_path }}/functions/build-next-releases')
          const conf                    = JSON.parse(process.env.CONFIG)
          const changes                 = JSON.parse(process.env.CHANGES)

          const result = buildNextReleases(conf, changes)

          core.startGroup('Next Release')
          console.log('next release:', JSON.stringify(result, null, 2))
          core.endGroup()

          core.setOutput('next-release-triggered', result.releaseRequired)
          core.setOutput('next-version', result.version)
          core.setOutput('next-release-type', result.releaseType)
          core.setOutput('scopes', result.scopes)

    - name: add labels to the PR
      if: >
        inputs.add-next-release-type-as-label-to-pr == 'true' || 
        inputs.add-commit-types-as-labels-to-pr     == 'true'
      uses: actions/github-script@v7
      env:
        RELEASE_TRIGGERED: ${{ steps.validate-commits.outputs.next-release-triggered }}
        NEXT_RELEASE_TYPE: ${{ steps.validate-commits.outputs.next-release-type }}
        CHANGES: ${{ steps.list-changes.outputs.changes }}
        ADD_RELEASE_TYPE_AS_LABEL: ${{ inputs.add-next-release-type-as-label-to-pr }}
        ADD_COMMIT_TYPES_AS_LABELS: ${{ inputs.add-commit-types-as-labels-to-pr }}
      with:
        script: |
          const releaseTriggered  = process.env.RELEASE_TRIGGERED === 'true'
          const nextReleaseType   = releaseTriggered ? process.env.NEXT_RELEASE_TYPE : 'no-release'
          const changes           = JSON.parse(process.env.CHANGES)
          const addReleaseType    = process.env.ADD_RELEASE_TYPE_AS_LABEL === 'true'
          const addCommitTypes    = process.env.ADD_COMMIT_TYPES_AS_LABELS === 'true'

          labels = []

          if(addReleaseType) {
            labels.push(nextReleaseType)
          }

          if(addCommitTypes) {
            changes
              .map(change => change.type)
              .filter((value, index, self) => self.indexOf(value) === index)
              .forEach(change => labels.push(change))
          }

          // ensure changes are uniques
          labels = labels.filter((value, index, self) => self.indexOf(value) === index)

          await github.rest.issues.addLabels({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.payload.pull_request.number,
            labels: labels
              })

    - name: printing summary
      if: ${{ inputs.print-summary == 'true' }}
      uses: actions/github-script@v7
      env:
        RELEASE_TRIGGERED: ${{ steps.validate-commits.outputs.next-release-triggered }}
        NEXT_RELEASE_TYPE: ${{ steps.validate-commits.outputs.next-release-type }}
        NEXT_VERSION: ${{ steps.validate-commits.outputs.next-version }}
      with:
        script: |
          const releaseTriggered = process.env.RELEASE_TRIGGERED === 'true'

          if (releaseTriggered) {
            const nextVersion     = process.env.NEXT_VERSION
            const nextReleaseType = process.env.NEXT_RELEASE_TYPE

            core.summary
              .addHeading('📽️ Next release')
              .addTable([
                [{ data: 'version', header: true }, { data: 'type', header: true }],
                [nextVersion, nextReleaseType]
              ])
              .write()

            if(nextReleaseType === 'major') {
              core.warning('⚠️ This is a major release, please check the changes carefully')
            }
          } else {
            core.summary
              .addRaw("changes won't trigger a new release")
              .write()
          }
